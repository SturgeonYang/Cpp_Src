// 题目描述
// 给定一个常数K和一个单链表L，要求按每K个节点反转单链表L。例如，给定L为1->2->3->4->5->6，如果K=3，应输出3->2->1->6->5->4，如果K=4，应输出4->3->2->1->5->6。

// 输入
// 每次输入一个案例，对于每一个案例：

// 第一行包含三个值：第一个节点的地址、节点总数N(<=10^5，正整数)、需要反转的子链表的长度K(<=N， 正整数)。

// 节点的地址是一个5位的非负整数，NULL用-1来代替。

// 下面接着输入N行，一行表示一个节点，格式为Address Data Next。其中Address为该节点的地址，Data为该节点的数据，Next为下一个节点的地址。

// ！！！注意：Address和Next字段都不是节点的真实存储地址，只是用来做示例，用于标识头节点和下一个节点是哪一个，真实的地址仍需要new出来后由计算机分配，不能直接向示例中的地址里写数据。

// 输出
// 对于每一个输入案例，输出反序后的单链表。其中每一个节点占一行，格式与输入一致。

// 样例输入
// 00100 6 4
// 00000 4 99999
// 00100 1 12309
// 68237 6 -1
// 33218 3 00000
// 99999 5 68237
// 12309 2 33218
// 样例输出
// 00000 4 33218
// 33218 3 12309
// 12309 2 00100
// 00100 1 99999
// 99999 5 68237
// 68237 6 -1
// 提示
注意：可能会有一些节点不在该单链表上，所以反序和输出的结果都不应包含这些节点。
#include <iostream>
using namespace std;

int main() {
    




    return 0;
}